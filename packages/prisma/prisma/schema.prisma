//
// Autogenerated by `prisma-import`
// Any modifications will be overwritten on subsequent runs.
//

//
// settings.prisma
//

generator client {
  provider = "prisma-client-js"
}

generator docs {
  provider = "node node_modules/prisma-docs-generator"
  output   = "../docs"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

//
// meta.prisma
//

model Meta {
  id              Int              @id @default(autoincrement()) @db.UnsignedInt
  title           String
  type            Type
  manga           Manga?
  anime           Anime?
  fiction         Fiction?
  anilistMeta     AnilistMeta?
  myAnimeListMeta MyAnimeListMeta?
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  latestContent   DateTime         @default(now())
}

model AnilistMeta {
  id         Int      @id @default(autoincrement()) @db.UnsignedInt
  anilistId  Int      @unique @db.UnsignedInt
  animeTitle String   @unique
  data       Json
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  meta       Meta     @relation(references: [id], fields: [metaId])
  metaId     Int      @unique @db.UnsignedInt
}

model MyAnimeListMeta {
  id         Int      @id @default(autoincrement()) @db.UnsignedInt
  malId      Int      @unique @db.UnsignedInt
  animeTitle String   @unique
  data       Json
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  meta       Meta     @relation(references: [id], fields: [id])
  metaId     Int      @unique @db.UnsignedInt
}

enum Type {
  ANIME
  MANGA
  FICTION
}

//
// anime.prisma
//

// TODO - Mechanism for grouping seasonal animes into a single instance

model Anime {
  id       Int       @id @db.UnsignedInt
  meta     Meta      @relation(fields: [id], references: [id], onDelete: Cascade)
  episodes Episode[]
}

model Episode {
  id             Int            @id @default(autoincrement()) @db.UnsignedInt
  sequenceNumber Int
  anime          Anime          @relation(fields: [id], references: [id], onDelete: Cascade)
  animeId        Int
  ServerSource   ServerSource[]
}

// ServerSource represents a single server source instance
// Episodes of an anime usually have a bunch of them per provider 
// For example see https://i.imgur.com/Ns5DKIV.png
model ServerSource {
  id           Int            @id @default(autoincrement()) @db.UnsignedInt
  serverNamme  String
  referer      String?
  Episode      Episode        @relation(fields: [episodeId], references: [id], onDelete: Cascade)
  episodeId    Int            @db.UnsignedInt
  streamSource StreamSource[]
}

// StreamSource represents a single instance of a media stream 
// For example see https://i.imgur.com/RNdVrva.png
model StreamSource {
  id             Int          @id @default(autoincrement()) @db.UnsignedInt
  quality        String
  url            String
  isM3U8         Boolean      @default(true)
  serverSource   ServerSource @relation(fields: [serverSourceId], references: [id], onDelete: Cascade)
  serverSourceId Int          @db.UnsignedInt
}

//
// fiction.prisma
//

model Fiction {
  fictionId      Int  @id @db.UnsignedInt
  meta           Meta @relation(fields: [fictionId], references: [id], onDelete: Cascade)
  totalChapters  Int
  currentChapter Int
}

//
// manga.prisma
//

model Manga {
  mangaId        Int  @id @db.UnsignedInt
  meta           Meta @relation(fields: [mangaId], references: [id], onDelete: Cascade)
  totalChapters  Int
  currentChapter Int
}
